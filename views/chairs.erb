<!DOCTYPE html>
<html>
<head>
	<title>Chairs</title>
	<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>	
	<link rel="stylesheet" type="text/css" href="css/chairs.css">
</head>
<body>

	<canvas id="canvas" width="600" height="600"></canvas>
	

	<script type="text/javascript">
	$(document).ready(function(){
		//canvas setup
		var startX, startY, topNodes, botNodes, topSideChains, primaryNode, secondaryNode, primarySC, secondarySC;
		var isDown = false;
		var canvas = document.getElementById("canvas");
		if(canvas.getContext){
			var context = canvas.getContext("2d");
			setNodes();
			drawSC();
		}
		
		$('#canvas').on('mousedown', function(evt){
			evt.stopPropagation();
      		evt.preventDefault();
			var downPositions = mousePosition(evt);
			startX = downPositions[0];
			startY = downPositions[1];
			isDown = true;
	    });

		$('#canvas').on('mousemove', function(evt) {
			if(!isDown){return;}
      		var x = mousePosition(evt)[0];
      		var y = mousePosition(evt)[1];
      		//if within a node
      		if(intersects(startX, startY, primaryNode[0], primaryNode[1], 10)){
      			if(isDown){
      				context.clearRect(0,0,canvas.width, canvas.height);
      				drawNodes();
					drawLine(x,y);
					getAngle(x,y);
				}
			}
		});

		$('#canvas').on('mouseup', function(evt){
			evt.stopPropagation();
      		evt.preventDefault();
			isDown = false;
			//check Angle of rotation from node origin	
		});


		//just for logging
		$('#canvas').on('click', function(evt){
			// var rect = canvas.getBoundingClientRect();
			// var x = Math.round((evt.clientX-rect.left)/(rect.right-rect.left)*canvas.width);
			// var y = Math.round((evt.clientY-rect.top)/(rect.bottom-rect.top)*canvas.height);
	   		var positions = mousePosition(evt);
	   		var x = positions[0];
	   		var y = positions[1];
		    console.log(x,y);

		    if(intersects(x,y,116,108,10)){
		    	console.log("intersects");
		    }
		});

		function getRandomInt(min, max) {
			return Math.floor(Math.random() * (max - min)) + min;
		}


		//set nodes. Counting starts at leftmost carbon and counts clockwise.''

		function setNodes(){
			console.log('setNodes');
			//coordinates of each node (x,y) from carbon-1 clockwise.
			topNodes = [[116,108], [266,141], [414,105], [492, 225], [345, 191], [195,227]];
			botNodes = [[109,494], [185,376], [336,414], [481,375], [405,495], [257,455]];
			//angles of rotation for axial and then equatorial. In degrees.
			topSideChains = [[90, 192], [270,120], [90,347], [270, 13], [90, 303], [270, 166]];

			botSideChains = [[270,166], [90, 192], [270, 57], [90, 345], [270, 15], [90, 235]];


			//choose a chair to draw on and a chair to be the template // 1 || 2
			var randy = getRandomInt(0,2);
			//setup primary and secondary nodes. They correspond to the appropriate carbons on the alternate conformation. Secondary Node is template, Primary Node is where the user draws from.  
			var rand = getRandomInt(0, topNodes.length);
			if(randy == 1){
				primaryNode = topNodes[rand];
				secondaryNode = botNodes[rand];
			}
			else{
				primaryNode = botNodes[rand];
				secondaryNode = topNodes[rand];
			}	
			drawNodes();
		}

		function drawNodes(){
			//draw nodes top
			for(var i = 0; i < topNodes.length; i++){
				var x = topNodes[i][0];
				var y = topNodes[i][1];
				context.beginPath();
				if(x === primaryNode[0] && y === primaryNode[1]){
					context.strokeStyle = 'green';
				}
				else if(x === secondaryNode[0] && y === secondaryNode[1]){
					context.strokeStyle = 'red'
				}
				else{	
					context.strokeStyle = 'black';
				}
				context.arc(x,y,10,0,2*Math.PI);
				context.closePath();
				context.stroke();
			}
			//draw bottom nodes
			for(var i = 0; i < botNodes.length; i++){
				var x = botNodes[i][0];
				var y = botNodes[i][1];
				context.beginPath();
				if(x === primaryNode[0] && y === primaryNode[1]){
					context.strokeStyle = 'green';
				}
				else if(x === secondaryNode[0] && y === secondaryNode[1]){
					context.strokeStyle = 'red'
				}
				else{
					context.strokeStyle = 'black';
				}
				context.arc(x,y,10,0,2*Math.PI);
				context.closePath();
				context.stroke();
			}
		}
		//getBoundingClientRect returns the dimensions of the canvas element including offsets, such as a border. This is used to adjust the mouse coordinates returned so that they correspond to the canvas directly and consistently.
		function mousePosition(evt){
			var rect = canvas.getBoundingClientRect();
			var x = Math.round((evt.clientX-rect.left)/(rect.right-rect.left)*canvas.width);
			var y = Math.round((evt.clientY-rect.top)/(rect.bottom-rect.top)*canvas.height);
			var array = [x, y];
			return array
		}

		function drawLine(x,y){
			context.beginPath();
			context.moveTo(primaryNode[0],primaryNode[1]);
			context.lineTo(x, y);
			context.closePath();
			context.stroke();
		}



		//called on mouse move
		function getAngle(x,y){
			var aX = x - primaryNode[0];
			var aY = y - primaryNode[1];
			//in Radians between [-PI <--> +PI]
			var theta = Math.atan2(-aY,aX);
			//for Non-negative values
			if(theta < 0){
				theta += 2 * Math.PI;
			}
			//to Degrees
			theta = theta * 180 / Math.PI;
			console.log(theta);
		}
		
		//http://stackoverflow.com/questions/2212604/javascript-check-mouse-clicked-inside-the-circle-or-polygon/2212851#2212851

		function intersects(x, y, cx, cy, r) {
			var dx = x - cx;
			var dy = y - cy;
			//Pythagorean Theorem
			return dx * dx + dy * dy <= r * r;
		}
		//draw side chain on a random chair at secondary node.
		function drawSC(){
			
		}

		//TODO list:
		// drag and drop line only from node. [x]
		//calculate degrees rotated from origin (node) [x]
		//randomize node appearance. [x]
		//randomize drawing between different chairs []
		//draw template and allow drawing only from corresponding node on opposite chair.[]
		//scoring []
		
	});
	</script>
</body>
</html>